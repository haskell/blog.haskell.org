
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://blog.haskell.org/abridge.css?h=d58d95c5efe846728d7b" />
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="base" content="https://blog.haskell.org" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#333333" />
  <meta name="msapplication-TileColor" content="#333333" />
  <link rel="manifest" href="https://blog.haskell.org/manifest.min.json" />
  <link rel="mask-icon" href="https://blog.haskell.org/safari-pinned-tab.svg" color="#ff9900" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://blog.haskell.org/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://blog.haskell.org/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://blog.haskell.org/favicon-16x16.png" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/source-sans-3-v9-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/ubuntu-mono-v15-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-700.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-900.woff2" type="font/woff2" />
  <link rel="alternate" type="application/atom+xml" title="The Haskell Programming Language&#x27;s blog Atom Feed" href="https://blog.haskell.org/atom.xml" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <title>Documentation Best Practices in 2024 | The Haskell Programming Language's blog</title>
  <meta name="author" content="Haskell.org" />
  <meta name="copyright" content="The Haskell Programming Language&#x27;s blog" />
  <meta name="description" content="" />
  <link rel="canonical" href="https://blog.haskell.org/documentation-best-practices-in-2024/" />
  <meta name="keywords" content="haskell, functional programming, blog" />
  <meta property="og:url" content="https://blog.haskell.org/documentation-best-practices-in-2024/" />
  <meta name="twitter:url" content="https://blog.haskell.org/documentation-best-practices-in-2024/" />
  <meta property="og:description" content="" />
  <meta name="twitter:description" content="" />
  <meta property="og:title" content="Documentation Best Practices in 2024 | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:title" content="Documentation Best Practices in 2024 | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:site_name" content="The Haskell Programming Language&#x27;s blog" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:updated_time" content="2024-09-15" />
  <script defer src="https://blog.haskell.org/js/abridge_nopwa.min.js?h=ad4669e842ae3b93e75c" integrity="sha384-L4qoD2LcUENkFpAPfhagH/avO0pb3xrSkp/zN5WETOjsol+2Kjx8eolYercZ3Z5k"></script>
  <noscript><link rel="stylesheet" href="https://blog.haskell.org/nojs.css" /></noscript>
</head>
<body>
  <header>
    <nav>
      <div><h1><a href="https://blog.haskell.org" title="The Haskell Programming Language&#x27;s blog"><img src="https://blog.haskell.org/images/haskell.svg" alt="Haskell" width="40" height="28" />Haskell Blog</a></h1></div>
      <div>

        <div>
          <ul><li><a class="s110" href="https:&#x2F;&#x2F;haskell.org"> Haskell </a></li><li><a class="s110" href="https://blog.haskell.org/archive/"> Posts </a></li><li><a class="s110" href="https://blog.haskell.org/categories/"> Categories </a></li><li><a class="s110" href="https://blog.haskell.org/about/"> About </a></li></ul>
        </div>

        <div>
          <div>
            <form autocomplete=off class="js" name="goSearch" id="searchbox">
              <div class="searchd">
                <input id="searchinput" type="text" placeholder="Search" title="Search" />
                <button type="submit" title="Search" class="svgs svgm search"></button>
              </div>
              <div class="results"><div id="suggestions"></div></div>
            </form>
          </div>
        </div>

      </div>
    </nav>
  </header>
  <main>
    <article>
      <h1><a href="https://blog.haskell.org/documentation-best-practices-in-2024/">Documentation Best Practices in 2024</a></h1>

      <span class="s95">
          <a href="https://blog.haskell.org/authors/hecate/">Hécate</a> <span class="rpad"></span> September 15, 2024 <span class="rpad"></span> [<a href="https://blog.haskell.org/categories/haddock/">Haddock</a>] #<a href="https://blog.haskell.org/tags/practices/">Practices</a>  #<a href="https://blog.haskell.org/tags/documentation/">Documentation</a> </span>

    


<p>In the Haddock team, part of our mission is to help with writing documentation, and promoting best practices. This article will help you write the best documentation you can!</p>
<span id="continue-reading"></span>
<p>We  adapt documentation outside practices to our ecosystem, and leverage our own technologies to empower Haskell users with their documentation work.</p>
<p>Let us see some of these techniques, and how the Haddock team can be of help.</p>
<h2 id="writing-documentation-for-your-software-project">Writing documentation for your software project</h2>
<h3 id="justify-yourself">Justify yourself</h3>
<p>When you create software, there is a pipeline from your brain straight to your code. Your decisions — such as the libraries you’ve used,
or your program architecture — shape how your code is structured and written.</p>
<p>Unfortunately, simply writing the code isn’t enough.The reasoning behind the decisions you made is as important as the decisions themselves. In the short term, solving a problem may let you move ahead immediately, but what keeps you on the correct path is understanding what
brought you to that solution.</p>
<p>Indeed, your choices may not be as popular as you think they are! Of course, you decided on them because you already convinced yourself
that they’re best. But you have a user base to convince as well, and they may not see things the same way you do.</p>
<p>As such, it is vitally important to document which decisions you made and to justify why you made them. If it’s not immediately obvious
why a behaviour or a pattern exists, future maintainers might be tempted to drop it — only to discover too late why it was needed.</p>
<h3 id="the-reference-flow-of-documentation">The reference flow of documentation</h3>
<p>Not all types of documentation have the same life cycle. Different pieces of documentation are more or less stable, and this determines
which can act as a conceptual and theoretical foundation for your project.</p>
<h4 id="stable-documentation">Stable documentation</h4>
<ul>
<li>A README without code</li>
<li>A vision statement</li>
<li>The value proposition and the core domain</li>
</ul>
<p>These ought not to change much, because they describe the basic problems that your code aims to address, solve or support in the long run.
While it is normal to fiddle around with the boundaries of your project at the beginning, in general these should change infrequently.</p>
<h4 id="volatile-documentation">Volatile documentation</h4>
<ul>
<li>Documentation generated at runtime</li>
<li>Code examples</li>
<li>Tests</li>
<li>Configuration</li>
</ul>
<p>These  are <em>expected</em> to change frequently, as your project changes, your API evolves, and you change configuration options.
Volatile documentation is expensive to maintain, but also very valuable, as it shows in a concrete way how the user can interact with
your project.</p>
<blockquote>
<p>“When you refer to something, make sure the direction of the reference is from the more volatile to the more stable elements”</p>
<p>-- Cyrille Martraire, Living Documentation, 2019</p>
</blockquote>
<h4 id="documentation-cascade">Documentation cascade</h4>
<p>Here is a simplified model of the documentation cascade for a typical Haskell project, from the most volatile to the most stable
sources:</p>
<img src="flow-of-documentation.png" alt="flow of documentation" width=70%>
<details><summary>Code for this diagram</summary>
<pre data-lang="markdown" class="language-markdown z-code"><code class="language-markdown" data-lang="markdown"><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">flowchart TD
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  A[Docs of your project]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  B[Architecture document]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  C[Official specs for your domain]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  D[&quot;Docs of a core library (base, text, containers, etc)&quot;]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  E[GHC Manual]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  F[Official specs for what the core libraries provide]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">  G[Papers]
</span></span><span class="z-text z-html z-markdown"><span class="z-meta z-paragraph z-markdown">
</span></span><span class="z-text z-html z-markdown">  A --&gt; B
</span><span class="z-text z-html z-markdown">  A --&gt; D 
</span><span class="z-text z-html z-markdown">  A --&gt; C
</span><span class="z-text z-html z-markdown">
</span><span class="z-text z-html z-markdown">  D --&gt; E
</span><span class="z-text z-html z-markdown">  D --&gt; F 
</span><span class="z-text z-html z-markdown">  D --&gt; G
</span></code></pre>
</details>
<p>This can be read as:</p>
<blockquote>
<p>The Haddocks of your library or a third-party library have a dependency on the official specs for the domain, on an architecture document,
and on haddocks from the core libraries (<code>base</code>, <code>text</code>, <code>containers</code>, etc.).
The haddocks of these core libraries depend on the GHC manual, official specs for their own domain, and papers.</p>
</blockquote>
<p>Keep in mind that while the Haddocks of a project can refer to the project specs, or to an architecture document, these documents should
never refer to the project's current implementation. If you must refer to the code, point to where it's located.
The (current, volatile) code cannot be the justification for the (planned, stable) architecture.</p>
<p>The GHC manual is much more stable than the haddocks of a Core library, which is why documentation should flow from
the library to the manual.</p>
<p>Finally, papers serve the same purpose as architecture documents, where they describe techniques that may be implemented,
but they should not point to code that is subject to change – lest they  point to a library that has evolved so much
that it no longer relates to the paper.</p>
<h4 id="example-the-set-data-structure">Example: The Set data structure</h4>
<p>The <a rel="noopener" target="_blank" href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Set.html">Haddocks for the <code>Set</code> datatype</a>
(from the <code>containers</code> library) are an example of documentation which follows this model well:</p>
<ul>
<li>They point to an overview of the API (<a rel="noopener" target="_blank" href="https://haskell-containers.readthedocs.io/en/latest/set.html">here</a>: <em>volatile</em>)</li>
<li>They refer to the papers that have informed the design of its implementation (<em>stable</em>)</li>
</ul>
<h3 id="understand-for-whom-you-write">Understand for whom you write</h3>
<img src="https://diataxis.fr/_images/diataxis.png" width=100%>
<blockquote>
<p>-- Diátaxis Framework, by Daniele Procida, <a rel="noopener" target="_blank" href="https://diataxis.fr">diataxis.fr</a></p>
</blockquote>
<p>It is of utmost importance that documentation answers the needs of the users, and for that we must understand these needs.
Users need specific kinds of documentation depending on the situation they are in.</p>
<p>The above quadrant is the Diátaxis Framework, which maps out the entire life cycle of one’s interaction with a system, a program or a library.
It defines four types of documentation where each are a combination of <em>Acquisition</em> or <em>Application</em>, and <em>Action</em> or <em>Cognition</em>.</p>
<h4 id="tutorials">Tutorials</h4>
<p>If a new user in need of actively acquiring some practice with the project, they can safely be pointed to the "<a rel="noopener" target="_blank" href="https://diataxis.fr/tutorials/">Tutorials</a>" part
of your documentation: it is the part that focuses on "<em>Acquisition</em>" of knowledge through "<em>Action</em>".
The focus of the tutorial is to make a prospective user acquire basic competence in handling the software: It is an ice-breaker.</p>
<h4 id="how-to-guides">How-to Guides</h4>
<p>Someone who needs to perform a task that new to them, but well-known to their group or organisation, will be best served by "<a rel="noopener" target="_blank" href="https://diataxis.fr/how-to-guides/">How-to Guides</a>",
which helps a user get something done in a safe and correct manner. As opposed to Tutorials, How-to Guides are directions that take into account the complexity of the environment
surrounding the the user and the action, instead of providing a single path from point A to point B.</p>
<h4 id="explanations">Explanations</h4>
<p>However someone who is in need of a deeper – but perhaps less immediately applicable understanding of the project –
will be better served by the "<a rel="noopener" target="_blank" href="https://diataxis.fr/explanation/">Explanation</a>", which serves the need for thought (or <em>Cognition</em>)</p>
<p>Explanations bring historical and technical context to the current state of affairs.</p>
<h4 id="reference">Reference</h4>
<p>Finally, a "<a rel="noopener" target="_blank" href="https://diataxis.fr/reference/">Reference</a>" is a description of the interfaces and mechanisms of the software.
It aims to provide factual informations that is authoritative, with no space for doubt or ambiguity or design questions.
The best way to obtain reference is to make the system aware of its inner workings, and have it spit the reference from its own code.</p>
<p>Through the lens of Diátaxis, the module API documentation produced by Haddock is a Reference.</p>
<p>The <a rel="noopener" target="_blank" href="https://swagger.io/specification/">OpenAPI standard</a> for documenting REST APIs is also a Reference, although some less fortunate systems find themselves
with no ability to understand their own mechanisms, and thus must rely on manually-written specifications.
In Haskell, packages like <a rel="noopener" target="_blank" href="https://flora.pm/packages/@hackage/openapi3">openapi3</a> help with rendering an OpenAPI specification,
whereas companion libraries for web servers like <a rel="noopener" target="_blank" href="https://flora.pm/packages/@hackage/servant-openapi3">servant-openapi3</a>
provide you with a way of declaring REST APIs that can be rendered, even at run-time.</p>
<h4 id="do-not-write-the-one-documentation">Do Not Write The One Documentation</h4>
<p>It is not just about filling out all the quadrants like a checklist (although they are all good to have!).
Instead, it is about understanding how each section focuses on a particular combination of user needs and situations.</p>
<p>The message of Diátaxis is that you are not meant to write The One Documentation that covers everything —
inevitably, this produces documentation which is shallow due to its breadth. Instead, focus on the strategic aspects of your documentation,
and you will produce documentation of better quality, with a clear purpose that it can fulfill more easily.</p>
<h2 id="reach-out">Reach Out</h2>
<p>Should you need any help in writing or proof-reading documentation, please stop by the <a rel="noopener" target="_blank" href="https://matrix.to/#/#haddock:matrix.org">Matrix chatroom</a> of the Haddock team,
or ping us with the <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/groups/haddock/-/group_members?sort=last_joined">@haddock</a> group tag on the
<a rel="noopener" target="_blank" href="https://gitlab.haskell.org/">Haskell Gitlab</a>. We would be more than happy to lend you a hand and discuss how to best serve your users,
you included.</p>
<h2 id="read-more">Read More</h2>
<ul>
<li><a rel="noopener" target="_blank" href="https://haskell-haddock.readthedocs.io/latest/">Haddock manual</a></li>
<li><a rel="noopener" target="_blank" href="https://diataxis.fr/theory/">The theory behind Diátaxis</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/utils/haddock/CONTRIBUTING.md?ref_type=heads">How to contribute to Haddock</a></li>
</ul>

      <nav>
        <div>
          <a href="https://blog.haskell.org/haskell-foundation-and-committee-merger/">&#8249; Haskell.org and the Haskell Foundation Join Forces</a>
        </div>
        <div>
          <a href="https://blog.haskell.org/report-of-js-code-minification/"> JavaScript Code Minification Report &#8250;</a>
        </div>
      </nav>
    </article>
  </main>
  <footer>
    <div class="c">
      <nav class="tpad"><div><a type="application/atom+xml" href="https://blog.haskell.org/atom.xml" target="_blank" title="The Haskell Programming Language&#x27;s blog Atom Feed"><i type="Button" class="svg rss" title="The Haskell Programming Language&#x27;s blog Atom Feed"></i></a><a href="https://fosstodon.org/@haskell" target="_blank" title="Mastodon" rel="me"><i type="Button" class="svg mastodon" title="Mastodon"></i></a><a href="https://twitter.com/haskellOrg/" target="_blank" title="Twitter"><i type="Button" class="svg twitter" title="Twitter"></i></a><a href="https://github.com/haskell&#x2F;blog.haskell.org/" target="_blank" title="Github"><i type="Button" class="svg github" title="Github"></i></a></div></nav>
      <p class="s80"> &copy; <span id="year">2025</span> The Haskell Programming Language's blog</p>
      <p class="s80">Powered by <a href="https://www.getzola.org/" target="_blank">Zola</a> & <a href="https://github.com/jieiku/abridge/" target="_blank">Abridge</a></p>
    </div>
  </footer><span class="topout">
<span class="topleft"> </span><a href="#" class="top" title="Back to Top"><i class="svgs svgh angu"></i></a>
</span>
</body>
</html>
