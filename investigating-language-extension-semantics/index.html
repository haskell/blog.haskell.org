
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://blog.haskell.org/abridge.css?h=d58d95c5efe846728d7b" />
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="base" content="https://blog.haskell.org" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#333333" />
  <meta name="msapplication-TileColor" content="#333333" />
  <link rel="manifest" href="https://blog.haskell.org/manifest.min.json" />
  <link rel="mask-icon" href="https://blog.haskell.org/safari-pinned-tab.svg" color="#ff9900" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://blog.haskell.org/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://blog.haskell.org/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://blog.haskell.org/favicon-16x16.png" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/source-sans-3-v9-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/ubuntu-mono-v15-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-700.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-900.woff2" type="font/woff2" />
  <link rel="alternate" type="application/atom+xml" title="The Haskell Programming Language&#x27;s blog Atom Feed" href="https://blog.haskell.org/atom.xml" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <title>Analyzing language extension semantics | The Haskell Programming Language's blog</title>
  <meta name="author" content="Haskell.org" />
  <meta name="copyright" content="The Haskell Programming Language&#x27;s blog" />
  <meta name="description" content="" />
  <link rel="canonical" href="https://blog.haskell.org/investigating-language-extension-semantics/" />
  <meta name="keywords" content="haskell, functional programming, blog" />
  <meta property="og:url" content="https://blog.haskell.org/investigating-language-extension-semantics/" />
  <meta name="twitter:url" content="https://blog.haskell.org/investigating-language-extension-semantics/" />
  <meta property="og:description" content="" />
  <meta name="twitter:description" content="" />
  <meta property="og:title" content="Analyzing language extension semantics | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:title" content="Analyzing language extension semantics | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:site_name" content="The Haskell Programming Language&#x27;s blog" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:updated_time" content="2025-11-30" />
  <script defer src="https://blog.haskell.org/js/abridge_nopwa.min.js?h=ad4669e842ae3b93e75c" integrity="sha384-L4qoD2LcUENkFpAPfhagH/avO0pb3xrSkp/zN5WETOjsol+2Kjx8eolYercZ3Z5k"></script>
  <noscript><link rel="stylesheet" href="https://blog.haskell.org/nojs.css" /></noscript>
</head>
<body>
  <header>
    <nav>
      <div><h1><a href="https://blog.haskell.org" title="The Haskell Programming Language&#x27;s blog"><img src="https://blog.haskell.org/images/haskell.svg" alt="Haskell" width="40" height="28" />Haskell Blog</a></h1></div>
      <div>

        <div>
          <ul><li><a class="s110" href="https:&#x2F;&#x2F;haskell.org"> Haskell </a></li><li><a class="s110" href="https://blog.haskell.org/archive/"> Posts </a></li><li><a class="s110" href="https://blog.haskell.org/categories/"> Categories </a></li><li><a class="s110" href="https://blog.haskell.org/about/"> About </a></li></ul>
        </div>

        <div>
          <div>
            <form autocomplete=off class="js" name="goSearch" id="searchbox">
              <div class="searchd">
                <input id="searchinput" type="text" placeholder="Search" title="Search" />
                <button type="submit" title="Search" class="svgs svgm search"></button>
              </div>
              <div class="results"><div id="suggestions"></div></div>
            </form>
          </div>
        </div>

      </div>
    </nav>
  </header>
  <main>
    <article>
      <h1><a href="https://blog.haskell.org/investigating-language-extension-semantics/">Analyzing language extension semantics</a></h1>

      <span class="s95">
          <a href="https://blog.haskell.org/authors/jappie-klooster/">Jappie Klooster</a> <span class="rpad"></span> November 30, 2025 <span class="rpad"></span> [<a href="https://blog.haskell.org/categories/haskell-foundation/">Haskell Foundation</a>] #<a href="https://blog.haskell.org/tags/community/">Community</a>  #<a href="https://blog.haskell.org/tags/stability/">Stability</a> </span>

    


<p>Hi I'm <a rel="noopener" target="_blank" href="https://jappie.me">Jappie</a> and I volunteer for the <a rel="noopener" target="_blank" href="https://blog.haskell.org/stability-working-group/">Haskell Foundation Stability Working Group</a>.
Recently we analyzed the <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/head.hackage">head.hackage</a> patches to understand
why code breaks on new GHC releases.
"head.hackage" is a repository of patches for Hackage.
GHC engineers use these to test out new GHC builds on a wide range of
Hackage packages without having to upstream<sup class="footnote-reference"><a href="#upstream">1</a></sup> a patch, which can take time.
Instead, they can put the patch in "head.hackage"
and immediately test it on a wide range of packages.
Surprisingly, most breakage wasn’t caused by
<a rel="noopener" target="_blank" href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/template_haskell.html">Template Haskell</a>,
it came from deeper semantic changes in language extensions.
The meaning of (some) language extensions changed between GHC releases.
This post walks through the main categories of breakage,
why they happened, and what they tell us about long-term stability.
If you care about a smoother upgrade path for Haskell users,
we invite you to participate in the <a rel="noopener" target="_blank" href="https://blog.haskell.org/stability-working-group/">Haskell Foundation Stability Working Group</a>.</p>
<p>Extending our initial <a rel="noopener" target="_blank" href="https://jappie.me/analyzing-haskell-stability.html">investigation</a>,
We're also interested in understanding <em>why</em> breakage occurs.
So we've recently done further analysis on <a rel="noopener" target="_blank" href="https://ghc.gitlab.haskell.org/head.hackage/">head.hackage</a>,
and learned surprisingly enough that the root cause
of a lot of breakage isn't Template Haskell,
but seems to be from language extension semantics<sup class="footnote-reference"><a href="#meaning">2</a></sup>.
We're doing this investigation to understand better where efforts
should be focused in improving stability.</p>
<p>This gave us the following table:</p>
<table><thead><tr><th>Name</th><th>Cause</th><th>Had warnings?</th></tr></thead><tbody>
<tr><td>Cabal-2.4.1.0.patch</td><td>simplified subsumption</td><td>no</td></tr>
<tr><td>Cabal-3.0.2.0.patch</td><td>simplified subsumption</td><td>no</td></tr>
<tr><td>Cabal-3.2.1.0.patch</td><td>simplified subsumption</td><td>no</td></tr>
<tr><td>data-r-tree-0.6.0.patch</td><td>parser change (see 1)</td><td>no</td></tr>
<tr><td>drinkery-0.4.patch</td><td>simplified subsumption</td><td>no</td></tr>
<tr><td>ghc-lib-parser-9.8.1.20231121.patch</td><td>rename forall identifiers (2)</td><td>yes</td></tr>
<tr><td>hgeometry-ipe-0.13.patch</td><td>Instances moved due to splice enforcement</td><td>no</td></tr>
<tr><td>singletons-3.0.2.patch</td><td>add TypeAbstractions as a language extension</td><td>yes</td></tr>
<tr><td>singletons-base-3.1.1.patch</td><td>add TypeAbstractions as a language extension</td><td>yes</td></tr>
<tr><td>vector-space-0.16.patch</td><td>Star is type (4)</td><td>yes</td></tr>
</tbody></table>
<p><code>th-compat-0.1.4.patch</code> was miscounted so I left that out.
Simplified subsumption appears a lot but 3 are for Cabal,
so it's only 2 real occurrences.
I'd expect that to appear a lot however,
because it was one of <em>the</em> motivating changes for a <a rel="noopener" target="_blank" href="https://blog.haskell.org/stability-working-group/">stability working group</a>.</p>
<h2 id="simplified-subsumption">Simplified subsumption</h2>
<p>For the blissfully ignorant reader simplified subsumption causes you
to do this under certain existential conditions:</p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"><span class="z-meta z-diff z-header z-from-file"><span class="z-meta z-header z-from-file z-diff"><span class="z-punctuation z-definition z-from-file z-diff">---</span> a/Distribution/Simple/Utils.hs
</span></span></span><span class="z-source z-diff"><span class="z-meta z-diff z-header z-to-file"><span class="z-meta z-header z-to-file z-diff"><span class="z-punctuation z-definition z-to-file z-diff">+++</span> b/Distribution/Simple/Utils.hs
</span></span></span><span class="z-source z-diff"><span class="z-meta z-diff z-range z-unified"><span class="z-meta z-range z-unified z-diff"><span class="z-punctuation z-definition z-range z-diff">@@</span> <span class="z-meta z-toc-list z-line-number z-diff">-1338,7 +1338,7</span> <span class="z-punctuation z-definition z-range z-diff">@@</span> <span class="z-entity z-name z-section z-diff">withTempFileEx opts tmpDir template action =</span>
</span></span></span><span class="z-source z-diff">     (\(name, handle) -&gt; do hClose handle
</span><span class="z-source z-diff">                            unless (optKeepTempFiles opts) $
</span><span class="z-source z-diff">                              handleDoesNotExist () . removeFile $ name)
</span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    (withLexicalCallStack (uncurry action))
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    (withLexicalCallStack (\x -&gt; uncurry action x))
</span></span></code></pre>
<p>You have to insert a lambda, which apparently has some performance impact.
This had a big impact on <a rel="noopener" target="_blank" href="https://www.yesodweb.com/book">Yesod stacks</a>,
whose code generation helpfully created
the database alias in the template:</p>
<pre data-lang="haskell" class="language-haskell z-code"><code class="language-haskell" data-lang="haskell"><span class="z-source z-haskell"><span class="z-keyword z-other z-haskell">type</span> <span class="z-constant z-other z-haskell">DB</span> a <span class="z-keyword z-operator z-haskell">=</span> forall (m <span class="z-keyword z-operator z-haskell">::</span> <span class="z-constant z-other z-haskell">Type</span> <span class="z-keyword z-operator z-haskell">-&gt;</span> <span class="z-constant z-other z-haskell">Type</span>)<span class="z-keyword z-operator z-haskell">.</span>
</span><span class="z-source z-haskell">    (<span class="z-constant z-other z-haskell">MonadUnliftIO</span> m) <span class="z-keyword z-operator z-haskell">=&gt;</span> <span class="z-constant z-other z-haskell">ReaderT</span> <span class="z-constant z-other z-haskell">SqlBackend</span> m a
</span></code></pre>
<p>Normally this is quite convenient,
however with the simplified subsumption change,
any code that interacts with the database now has to insert those lambdas.
As you can imagine this would in many places for a commercial code base.
Causing a lot of compile errors for industrial users.
Instead of inserting lambdas, you can also delete those existential aliases to solve the problem.
Or you can enable the language extension: <a rel="noopener" target="_blank" href="https://downloads.haskell.org/~ghc/9.12.2/docs/users_guide/exts/rank_polymorphism.html#extension-DeepSubsumption">DeepSubsumption</a>.
Which restores the original behavior.</p>
<h2 id="moving-of-instances-due-to-template-haskell">Moving of instances due to Template Haskell</h2>
<p>This change forces you to put the instances above the splice where
they are being used in the same module.
A dear colleague decided to generate instances in Template Haskell.
That was quite the puzzle!
I asked the GHC devs why they did this,
and it turns out this was a soundness issue in the typechecker.
Here, soundness means the type system can't be tricked into allowing invalid programs.
So the community is better off, despite this causing a fair bit of work.</p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"><span class="z-meta z-diff z-header z-from-file"><span class="z-meta z-header z-from-file z-diff"><span class="z-punctuation z-definition z-from-file z-diff">---</span> a/src/Ipe/Content.hs
</span></span></span><span class="z-source z-diff"><span class="z-meta z-diff z-header z-to-file"><span class="z-meta z-header z-to-file z-diff"><span class="z-punctuation z-definition z-to-file z-diff">+++</span> b/src/Ipe/Content.hs
</span></span></span><span class="z-source z-diff"><span class="z-meta z-diff z-range z-unified"><span class="z-meta z-range z-unified z-diff"><span class="z-punctuation z-definition z-range z-diff">@@</span> <span class="z-meta z-toc-list z-line-number z-diff">-288,6 +288,14</span> <span class="z-punctuation z-definition z-range z-diff">@@</span>
</span></span></span><span class="z-source z-diff">
</span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>instance Fractional r =&gt; IsTransformable (IpeObject r) where
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>  transformBy t (IpeGroup i)     = IpeGroup     $ i&amp;core %~ transformBy t
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span> ...
</span></span><span class="z-source z-diff"> makePrisms &#39;&#39;IpeObject
</span><span class="z-source z-diff">
</span><span class="z-source z-diff"><span class="z-meta z-diff z-range z-unified"><span class="z-meta z-range z-unified z-diff"><span class="z-punctuation z-definition z-range z-diff">@@</span> <span class="z-meta z-toc-list z-line-number z-diff">-303,14 +311,6</span> <span class="z-punctuation z-definition z-range z-diff">@@</span>
</span></span></span><span class="z-source z-diff">
</span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>instance Fractional r =&gt; IsTransformable (IpeObject r) where
</span></span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>  transformBy t (IpeGroup i)     = IpeGroup     $ i&amp;core %~ transformBy t
</span></span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span> ...
</span></span></code></pre>
<h2 id="1-parser-change">(1) Parser change</h2>
<p>The parser is the component of the compiler that transforms text
into a memory structure the compiler can work with.
This structure is called an abstract syntax tree.</p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>      Node4 {getMBB :: {-# UNPACK #-} ! MBB, getC1 :: ! (RTree a), getC2 :: ! (RTree a), getC3 :: ! (RTree a), getC4 :: ! (RTree a) }
</span></span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    | Node3 {getMBB :: {-# UNPACK #-} ! MBB, getC1 :: ! (RTree a), getC2 :: ! (RTree a), getC3 :: ! (RTree a) }
</span></span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    | Node2 {getMBB :: {-# UNPACK #-} ! MBB, getC1 :: ! (RTree a), getC2 :: ! (RTree a) }
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>      Node4 {getMBB :: {-# UNPACK #-} !MBB, getC1 :: !(RTree a), getC2 :: !(RTree a), getC3 :: !(RTree a), getC4 :: !(RTree a) }
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    | Node3 {getMBB :: {-# UNPACK #-} !MBB, getC1 :: !(RTree a), getC2 :: !(RTree a), getC3 :: !(RTree a) }
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    | Node2 {getMBB :: {-# UNPACK #-} !MBB, getC1 :: !(RTree a), getC2 :: !(RTree a) }
</span></span><span class="z-source z-diff">     | Node  {getMBB ::                  MBB, getChildren&#39; :: [RTree a] }
</span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    | Leaf  {getMBB :: {-# UNPACK #-} ! MBB, getElem :: a}
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    | Leaf  {getMBB :: {-# UNPACK #-} !MBB, getElem :: a}
</span></span><span class="z-source z-diff">     | Empty
</span><span class="z-source z-diff">
</span></code></pre>
<p>This is a change from all the way back in 2020, where the <em>core</em> language changed by
disallowing <code>!</code> before parens.
Here the bang <code>!</code> indicates strict fields.
Technically this doesn't fit into the category
because the core language isn't a language extension.
But semantics did change!
Actually I don't think we expected to find something like this at all.
I'm not sure how relevant this is to discuss further because it appears
quite rare for someone to do this.
You can enable <a rel="noopener" target="_blank" href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/strict.html#extension-StrictData">StrictData</a>
in your Cabal file and delete all those bangs!</p>
<h2 id="2-rename-forall-identifiers">(2) Rename forall identifiers</h2>
<p>This changes the forall identifier into a keyword at term level.
It already was at the type level.
The issue is discussed <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/23719">here</a></p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"> hintExplicitForall :: Located Token -&gt; P ()
</span><span class="z-source z-diff"> hintExplicitForall tok = do
</span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    forall   &lt;- getBit ExplicitForallBit
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    forAll   &lt;- getBit ExplicitForallBit
</span></span><span class="z-source z-diff">     rulePrag &lt;- getBit InRulePragBit
</span><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>    unless (forall || rulePrag) $ addError $ mkPlainErrorMsgEnvelope (getLoc tok) $
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>    unless (forAll || rulePrag) $ addError $ mkPlainErrorMsgEnvelope (getLoc tok) $
</span></span><span class="z-source z-diff">       (PsErrExplicitForall (isUnicode tok))
</span></code></pre>
<h2 id="3-typeabstractions">(3) TypeAbstractions</h2>
<p>From what I understand from the <a rel="noopener" target="_blank" href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_abstractions.html#type-abstractions">manual</a>
is that part of the syntax for type abstractions landed in GHC 9.2,
however 9.8 and onwards requires you to enable this language extension.
This appeared because certain new functionality was introduced behind an
old language extension flag, according to <a rel="noopener" target="_blank" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0448-type-variable-scoping.rst#4type-arguments-in-constructor-patterns">this proposal</a>. It says we don't want to introduce new functionality behind established extensions,
so that's why we require TypeAbstractions now,
where previously ScopedTypeVariables and TypeApplications were enough.</p>
<p>This extension enables you to bind type variables in pattern matches.
I don't know why this happened like this, but it happened in 2023:</p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>-- Invisible type binders in type declarations, such as
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>--
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>--   type family Sing @k
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>--
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>-- require the TypeAbstractions extension.
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>#if __GLASGOW_HASKELL__ &gt;= 909
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>{-# LANGUAGE TypeAbstractions #-}
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>#endif
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>
</span></span></code></pre>
<h2 id="4-star-is-type">(4) Star is type</h2>
<p>This change was announced via a warning.
It tells users to write <code>Type</code> instead of <code>*</code> for kinds representing types.
A kind is essentially the type of a type,
and as a concept is used for type-level programming type safety.</p>
<pre data-lang="diff" class="language-diff z-code"><code class="language-diff" data-lang="diff"><span class="z-source z-diff"><span class="z-markup z-deleted z-diff"><span class="z-punctuation z-definition z-deleted z-diff">-</span>  type Basis v :: *
</span></span><span class="z-source z-diff"><span class="z-markup z-inserted z-diff"><span class="z-punctuation z-definition z-inserted z-diff">+</span>  type Basis v :: Type
</span></span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Often these breakages are annoying and frustrating.
But if we look deeper, we find that each of them has
a little story
and good reasons for being introduced.
If you find this all as interesting as I do,
please consider joining some of the stability
working group meetings!</p>
<div class="footnote-definition" id="upstream"><sup class="footnote-definition-label">1</sup>
<p>Upstreaming is the process of sending a patch to the “maintainers” of an open-source project. The maintainers will then make the patch ‘official’ by merging it. In principle, the process is simple, but in practice, the burden of proof (especially for larger projects) is on the person who submitted the patch. They have to convince the maintainers that the patch is useful, which takes time in the form of communication</p>
</div>
<div class="footnote-definition" id="meaning"><sup class="footnote-definition-label">2</sup>
<p>The precise meaning of features enabled by language extensions. I guess parser changes also count.</p>
</div>

      <nav>
        <div>
        </div>
        <div>
          <a href="https://blog.haskell.org/gsoc-2025/"> Google Summer of Code 2025 Wrap-up &#8250;</a>
        </div>
      </nav>
    </article>
  </main>
  <footer>
    <div class="c">
      <nav class="tpad"><div><a type="application/atom+xml" href="https://blog.haskell.org/atom.xml" target="_blank" title="The Haskell Programming Language&#x27;s blog Atom Feed"><i type="Button" class="svg rss" title="The Haskell Programming Language&#x27;s blog Atom Feed"></i></a><a href="https://fosstodon.org/@haskell" target="_blank" title="Mastodon" rel="me"><i type="Button" class="svg mastodon" title="Mastodon"></i></a><a href="https://twitter.com/haskellOrg/" target="_blank" title="Twitter"><i type="Button" class="svg twitter" title="Twitter"></i></a><a href="https://github.com/haskell&#x2F;blog.haskell.org/" target="_blank" title="Github"><i type="Button" class="svg github" title="Github"></i></a></div></nav>
      <p class="s80"> &copy; <span id="year">2025</span> The Haskell Programming Language's blog</p>
      <p class="s80">Powered by <a href="https://www.getzola.org/" target="_blank">Zola</a> & <a href="https://github.com/jieiku/abridge/" target="_blank">Abridge</a></p>
    </div>
  </footer><span class="topout">
<span class="topleft"> </span><a href="#" class="top" title="Back to Top"><i class="svgs svgh angu"></i></a>
</span>
</body>
</html>
