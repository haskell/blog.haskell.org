
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://blog.haskell.org/abridge.css?h=d58d95c5efe846728d7b" />
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="base" content="https://blog.haskell.org" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#333333" />
  <meta name="msapplication-TileColor" content="#333333" />
  <link rel="manifest" href="https://blog.haskell.org/manifest.min.json" />
  <link rel="mask-icon" href="https://blog.haskell.org/safari-pinned-tab.svg" color="#ff9900" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://blog.haskell.org/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://blog.haskell.org/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://blog.haskell.org/favicon-16x16.png" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/source-sans-3-v9-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/ubuntu-mono-v15-latin-regular.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-700.woff2" type="font/woff2" />
  <link rel="preload" as="font" href="https://blog.haskell.org/fonts/raleway-v28-latin-900.woff2" type="font/woff2" />
  <link rel="alternate" type="application/atom+xml" title="The Haskell Programming Language&#x27;s blog Atom Feed" href="https://blog.haskell.org/atom.xml" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <title>JavaScript Code Minification Report | The Haskell Programming Language's blog</title>
  <meta name="author" content="Haskell.org" />
  <meta name="copyright" content="The Haskell Programming Language&#x27;s blog" />
  <meta name="description" content="" />
  <link rel="canonical" href="https://blog.haskell.org/report-of-js-code-minification/" />
  <meta name="keywords" content="haskell, functional programming, blog" />
  <meta property="og:url" content="https://blog.haskell.org/report-of-js-code-minification/" />
  <meta name="twitter:url" content="https://blog.haskell.org/report-of-js-code-minification/" />
  <meta property="og:description" content="" />
  <meta name="twitter:description" content="" />
  <meta property="og:title" content="JavaScript Code Minification Report | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:title" content="JavaScript Code Minification Report | The Haskell Programming Language&#x27;s blog" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:image" content="https://blog.haskell.org/images/haskell-opengraph.png" />
  <meta property="og:site_name" content="The Haskell Programming Language&#x27;s blog" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:updated_time" content="2024-09-15" />
  <script defer src="https://blog.haskell.org/js/abridge_nopwa.min.js?h=ad4669e842ae3b93e75c" integrity="sha384-L4qoD2LcUENkFpAPfhagH/avO0pb3xrSkp/zN5WETOjsol+2Kjx8eolYercZ3Z5k"></script>
  <noscript><link rel="stylesheet" href="https://blog.haskell.org/nojs.css" /></noscript>
</head>
<body>
  <header>
    <nav>
      <div><h1><a href="https://blog.haskell.org" title="The Haskell Programming Language&#x27;s blog"><img src="https://blog.haskell.org/images/haskell.svg" alt="Haskell" width="40" height="28" />Haskell Blog</a></h1></div>
      <div>

        <div>
          <ul><li><a class="s110" href="https:&#x2F;&#x2F;haskell.org"> Haskell </a></li><li><a class="s110" href="https://blog.haskell.org/archive/"> Posts </a></li><li><a class="s110" href="https://blog.haskell.org/categories/"> Categories </a></li><li><a class="s110" href="https://blog.haskell.org/about/"> About </a></li></ul>
        </div>

        <div>
          <div>
            <form autocomplete=off class="js" name="goSearch" id="searchbox">
              <div class="searchd">
                <input id="searchinput" type="text" placeholder="Search" title="Search" />
                <button type="submit" title="Search" class="svgs svgm search"></button>
              </div>
              <div class="results"><div id="suggestions"></div></div>
            </form>
          </div>
        </div>

      </div>
    </nav>
  </header>
  <main>
    <article>
      <h1><a href="https://blog.haskell.org/report-of-js-code-minification/">JavaScript Code Minification Report</a></h1>

      <span class="s95">
          <a href="https://blog.haskell.org/authors/serge-s-gulin/">Serge S. Gulin</a> <span class="rpad"></span> September 15, 2024 <span class="rpad"></span> [<a href="https://blog.haskell.org/categories/ghc/">GHC</a>] #<a href="https://blog.haskell.org/tags/activities-report/">activities-report</a>  #<a href="https://blog.haskell.org/tags/javascript/">javascript</a> </span>

    


<p>The JavaScript world has been battling for low bundle size from the very beginning.
It is now our turn to enter the battle</p>
<span id="continue-reading"></span>
<p><strong>Dedicated to all front-end developers who doubt, but.</strong></p>
<h2 id="intro">Intro</h2>
<p>The JavaScript backend in GHC has a long history of various challenges. One of the most notable is the transition from GHC 8.x to 9.x. Significant work has been done up to today by the GHC team, and progress is still ongoing. Besides the obvious need to make the GHC JavaScript backend functional in general, some specific issues have been raised regarding its use in production, one of them being the size of the produced JavaScript bundles.</p>
<p>Bundle size is an important consideration when commercial applications face challenges in delivering to end users. It is not surprising that consumers pay attention to software user experience. First impressions matter, and the time required for a fully functional interface to appear on the user's device is crucial.</p>
<p>Web applications are particularly sensitive to the duration before user interactions can begin. When you are loading a site or web application, you <a rel="noopener" target="_blank" href="https://www.browserstack.com/guide/how-fast-should-a-website-load">expect it to be fast</a>. Bundle size is a primary target for loading time optimizations, due to the fact that, at this point, you have little control over what to offer the user while the progress bar is filling up.</p>
<h2 id="bundle-size-challenge">Bundle Size Challenge</h2>
<p>The JavaScript world has been battling for low bundle size from the very beginning. Various tactics have been developed up to today. Everyone who has participated in web development has heard words like minification, obfuscation, compression, and code elimination. Each of these terms opens a door to a wide array of tools whose configuration can take a long time and requires special experience: the resulting bundle should not only be lightweight but also functional.</p>
<p>Roughly speaking, we can categorize all these tools and approaches into the following set of practical actions:</p>
<ol>
<li><strong>Code rewrite</strong>. Simple approaches are known as minification. They are based on the fact that JavaScript supports pulling all code into a single line by removing whitespace. More intelligent approaches swap variable names for shorter ones. A side effect of this is that it makes reading such code harder, which in itself is a practice known as obfuscation. Even more advanced tools support unused (dead) code detection, allowing it to be safely removed. How can this happen? Third-party libraries provide various functions, but a specific application uses only a subset of them. The most advanced tools take things a step further: they can detect some code that can be rewritten in a more optimal form according to its actual use cases. For instance, if you use a constant variable, its value can be substituted directly in a call. In that case, the variable definition itself is not important and can be omitted, with its value used in place (inlined).</li>
<li><strong>Environment-dependent graceful degradation</strong>. The runtime environment can vary significantly due to different browsers and their versions. Sometimes you have control over the user's runtime environment, especially if the application is targeted at commercial clients. More often, your runtime environment is very diverse. Different environments impose different restrictions. Rich (and probably more modern) environments provide a large set of built-in features. The way you deliver your programs could depend on these features, as they can help build optimal bundles where your code does not have to implement low-level behaviors from scratch. Such code can have shortcuts for features where there is no need to include the full implementation, which would add more to the bundle. For example, <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">internationalization</a> (i18n) can be supported by some targets, so you do not need to add a full implementation in your code. This approach encourages modern user environments with faster load times, but for others, it makes things "just work" at the cost of bundle size. Web servers can detect browsers and their versions to select the best bundle size using the <code>User-Agent</code> header.</li>
<li><strong>Network-level compression</strong>. The simplest approach to reducing load time is to use good old compression, usually gzip compression. There is no need to deal with code optimizations. Most environments support it "out of the box" through the provided <code>Content-Encoding</code> header. It has its own weakness: the time to unpack the application on the client side. However, such a concern has become less important these days, thanks to modern CPUs‚Äîeven on low-budget devices.</li>
<li><strong>Dynamic bundle loading</strong>. This is the last but not least option when no other ways give you satisfactory results in the battle for short loading times. Usually, even large applications can be split into smaller parts that can be loaded as the user navigates through the interface. It is an old approach used on the Web: hypertext itself encourages this way of loading time optimization. Modern web applications can be designed to load their parts one by one if the tools used support partial loading.</li>
</ol>
<h2 id="javascript-ecosystem">JavaScript ecosystem</h2>
<p>As mentioned in the previous part, the modern JavaScript ecosystem provides battle-tested approaches to dealing with bundle size. The most notable ones that come to mind include:</p>
<ol>
<li><a rel="noopener" target="_blank" href="https://terser.org/">Terser</a>, <a rel="noopener" target="_blank" href="https://www.uglifyjs.net/">UglifyJS</a>, and <a rel="noopener" target="_blank" href="https://developers.google.com/closure/compiler">Google Closure Compiler</a>. All of them provide methods to transform code into a minified form, ranging from trivial optimizations to more advanced techniques like dead code elimination.</li>
<li><a rel="noopener" target="_blank" href="https://babeljs.io/">Babel</a> for environment-related optimizations. Its primary purpose is to construct a set of "polyfills" that ensure uniform code execution across environments with different capabilities. Babel does not know a priori which capabilities an environment has, but it can be configured declaratively at build time to specify which features are expected to be present or not. One possible scenario for its usage in the task of bundle size reduction is to categorize possible environments into classes and prepare specific builds for each class. Bundle selection for delivery can be fulfilled by the static content server. For example, this can be implemented with the help of <a rel="noopener" target="_blank" href="https://nginx.org/en/">Nginx</a>, where bundles can be associated with the incoming <code>User-Agent</code> header.</li>
<li><a rel="noopener" target="_blank" href="https://webpack.js.org/">Webpack</a> (<a rel="noopener" target="_blank" href="https://parceljs.org/">Parcel</a>, <a rel="noopener" target="_blank" href="https://rollupjs.org/">Rollup</a>) for bundle combining and splitting. The modern JavaScript environment has <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">support</a> for code modularization, but this support is still far from perfect. Even if support becomes more widespread, bundling will probably remain important due to networking: loading one big file generally has fewer side effects on time than loading a set of files with the same total size. Bundlers come into play when your application consists of a large number of modules, which is a common case. Moreover, they add additional value to the application build pipeline: they provide a way to slice a large application into a few bundles that can be loaded dynamically. Such slicing can usually be configured declaratively.</li>
<li><a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Gzip">Gzip</a>, <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Deflate">Deflate</a>, and <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Brotli">Brotli</a> via <a rel="noopener" target="_blank" href="https://nginx.org/en/">Nginx</a> through <a rel="noopener" target="_blank" href="https://bytepursuits.com/nginx-enabling-brotli-compression-with-gzip-fallback">fallback</a> on the <code>Content-Encoding</code> header value. Their usage is quite straightforward. It depends only on the selected delivery method. Usually, web servers and content delivery networks handle this task with the best available efforts, so it is very rare that any manual tweaking is needed.</li>
</ol>
<h2 id="the-haskell-way">The Haskell way</h2>
<p>Let us return to our primary topic and consider how the Haskell environment takes its own seat with the concepts described above.</p>
<p><strong>Network-level compression</strong> does not depend on how the JavaScript bundle is generated. It is the most accessible way to address the issue of large bundle sizes. We assume that it is enabled by default and, for measurement purposes, we assume that <code>Gzip</code> is used. So, even if the GHC JavaScript backend does not support anything from the list above related to code splitting or code optimizations, we can still improve user experience by reducing bundle loading time through the correct configuration of the delivery channel to use reliable old compression.</p>
<blockquote>
<p>So, there are no troubles here ‚úÖ‚úÖ.</p>
</blockquote>
<p><strong>Dynamic bundle loading</strong> is a complex topic. The GHC JavaScript bundle does not support it natively. However, real-world JavaScript applications usually depend on other JavaScript libraries and modules. We assume that a Haskell application could depend on them: call their functions, return results to them, and be called from external JavaScript code. Currently, the GHC 9.x JavaScript backend lacks full support for FFI. It allows only functions as JavaScript imports. However, it is enough to construct the interface where JavaScript can call Haskell functions and vice versa. Thus, we cover two possible top-level architecture scenarios:</p>
<ol>
<li>Haskell is used to write modules that will be used by some top-level JavaScript code. Such JavaScript code could be used only for bootstrapping purposes actually. In that scenario, bundlers (i.e., Webpack) could consider Haskell code as an <a rel="noopener" target="_blank" href="https://webpack.js.org/guides/shimming/#global-exports">old-fashioned</a> JavaScript module that operates through globally exported functions. By this assumption, we gain the full power of slicing our application with a bundler, but its atomic slice is limited to the whole JavaScript bundle from the GHC 9.x JavaScript backend because it is a kind of "black box" for the bundler. Thus, it allows you to write different parts of the application in different Haskell modules which could be loaded on-demand from the top-level JavaScript code. The main issue here is to write a correct rule for loading such an "old-fashioned" module. A Haskell module (when Emscripten is used) can contain some global variables which require lots of care from the bundler side to ensure they are loaded sequentially by time but safely "shimmed" for simultaneous usage in the global JavaScript namespace.</li>
<li>Haskell is used to write a top-level module that is supposed to be a caller for dependent JavaScript modules. It is supposed that this way is primary for existing commercial frontend applications written in Haskell for the Web. That looks like a straightforward way to begin development but encourages limited benefits from existing JavaScript bundlers. They can be used only to prepare third-party libraries for external calls. The GHC 8.x/9.x JavaScript linker currently does not support dynamically loading dependent Haskell modules on-demand: it assumes that all Haskell code is present statically at the moment of application bootstrap.</li>
</ol>
<blockquote>
<p>Well, this way of bundle size optimization is limited even if possible. Even if the first strategy is chosen, the process of keeping the bundle configuration correct throughout the development lifecycle will require deep knowledge and lots of patience. Not sure what is more, so ü§∑‚Äç‚ôÇÔ∏è.</p>
</blockquote>
<p>Accommodation of this tactic will not be covered by the samples in this article, but it could be an interesting journey for developers who participate in large Haskell web frontend application support. If it finds a strong response from the community, it could be investigated further.</p>
<p><strong>Environment-dependent graceful degradation</strong> is related to the previously discussed topic. Such tools (i.e., <code>Babel</code>) in the JavaScript ecosystem tend to be used in conjunction with bundlers (i.e., <code>Webpack</code>), but some of them can be used standalone. Their practical purpose for Haskell applications lies in providing a stable environment with all modern features of ECMAScript implemented natively or through "polyfills." Unfortunately, <a rel="noopener" target="_blank" href="https://ponyfoo.com/articles/polyfills-or-ponyfills">"ponyfills"</a> cannot be used with Haskell frontend applications due to the lack of support for CommonJS/ESM modules in the GHC 8.x/9.x JavaScript backend linker. Fortunately, the GHC 8.x/9.x JavaScript backend generates a very simple JavaScript subset. GHC's JavaScript RTS library has been written with ES5 in mind, with minor inclusions of fat-<a rel="noopener" target="_blank" href="https://caniuse.com/arrow-functions">arrow-style</a> functions from ES6. The used ES-language features are broadly supported nowadays. So, if your code does not use third-party libraries in JavaScript (which is supposed to be a rare case for real-world commercial applications), the usage of tools like <code>Babel</code> does not seem necessary.</p>
<p>On the other hand, even a <code>Hello World</code>-like Haskell application comes with a rich set of built-in modules for everyday use. Some modules of i18n and bigint from built-in libraries could be swapped for ones from a stable environment. This could reduce the size of generated JavaScript bundles for modern environments where "polyfills" are not needed. For older environments, such "polyfills" could be incorporated through declarative <code>Babel</code> configuration.</p>
<p>We face two scenarios of graceful degradation tool usage for a Haskell web frontend application:</p>
<ol>
<li>Third-party JavaScript libraries may require them. There is a <strong>dash</strong> in the JavaScript world. Authors of popular and reliable libraries tend to use the most modern and fashionable ECMAScript features. This adds additional complexity for Haskell application distribution. Such libraries need to pass through tools like <code>Babel</code> before being added to the resulting bundle.</li>
<li>The Haskell application itself relies on built-in packages, which is fine in terms of reliable execution (one of Haskell's strong sides) but not so well with bundle size when the environment provides native or "polyfilled" implementations for basic functions to work with things like <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">i18n</a> and Bignum (<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>).</li>
</ol>
<blockquote>
<p>In short, this way of optimization has little to do with the Haskell application itself for now. It can be integrated into the resulting bundle compilation to process third-party JavaScript dependencies ‚úÖ, but currently, GHC 9.x JavaScript does not support swapping functions from built-in packages with those provided by the environment ‚ùå.</p>
</blockquote>
<p>Experiments with this tactic remain out of scope for the current attempt to bring some benefits. Here, the same action is relevant as for the previous one: strong response from the community could drive investigations into this field.</p>
<p><strong>Code rewrite</strong> is a common tactic for advanced bundle size optimizations. Besides using optimizing compilers like Google Closure Compiler, the GHC 8.x/9.x JavaScript backend offers features to deal with large bundle sizes. The overview of introduced improvements in this area will be covered in the next section of this article and measured. Also, it is important to keep the resulting bundle compatible with existing optimizing compilers (at least one of them) because it provides additional benefits for application developers.</p>
<p>Although a long route still lies ahead, some steps have already come into play nowadays: optimizing compiler support has been fixed, Unicode dead code elimination improved, string representation optimized, and Unicode (again!) table size notably reduced. ‚úÖ Let us see the details in the next section!</p>
<h2 id="passed-steps-for-great-good">Passed steps for great good</h2>
<p>Before anything else, it's necessary to mention that the initial event that sparked this work was an offline discussion where the opinion was formed that even a 100kb total bundle size for a Haskell "Hello World" application is not achievable.</p>
<p>Well, does it really matter? We will measure it with <a rel="noopener" target="_blank" href="https://github.com/ai/size-limit">size-limit</a>, which shows sizes and time to load on a bad connection.</p>
<p>We are going to begin from the <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/commit/7d84df86d8c639a9ef442593d4a8c017a2046b92">latest</a> <code>master</code> commit at the time of writing this article. Right on this commit, we will revert the added code optimizations:</p>
<ol>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24789">#24789</a> Reasoning on Unicode static data compression on the GHC side</li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24504">#24504</a> Eliminate dependency of "Hello World" on <code>Read</code></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24706">#24706</a> Port back more efficient packing of string data from GHCJS to GHC JavaScript backend</li>
</ol>
<p>The order is important. They were added in reverse order, so applying reverts to related commits reconstructs the whole GHC state. We want to take the most modern (and buildable!) GHC state and see how the JavaScript bundle size is improved over these commits.</p>
<p>Additionally, it's important to note that there is one more significant issue:</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24602">#24602</a> Google Closure Compiler hard errors</li>
</ul>
<p>It is important, but it does not add optimizations to GHC itself. It only allows us to run the Google Closure Compiler over the resulting bundle, which we can turn on/off manually during the following steps. We will apply all measurements with and without it to track its necessity.</p>
<p>Our building pipeline will be the following:</p>
<ol>
<li>Build a sample Haskell program with <code>GHC</code> optimization option <code>-O2</code>.</li>
<li>Process <code>all.js</code> through <code>Google Closure Compiler</code> with <code>--compilation_level ADVANCED_OPTIMIZATIONS</code>.</li>
<li>Process <code>all.js</code> and <code>all.min.js</code> (result of the Google Closure Compiler) with <code>size-limit</code>.</li>
</ol>
<p>We will measure the following:</p>
<ol>
<li>The size of <code>all.js</code> after the <code>GHC</code> pass</li>
<li>The size of <code>all.min.js</code> after the Google Closure pass</li>
<li>The brotlied sizes of them both via <code>size-limit</code></li>
<li>The running time via <code>size-limit</code> to estimate how hard it is for the browser to load on a low budget device. It uses <a rel="noopener" target="_blank" href="https://github.com/mbalabash/estimo?tab=readme-ov-file#chrome-device-emulation">estimo</a> internally.</li>
</ol>
<p>Lets do some initial measurements (when no improvements have been applied via the reverted commits on fresh master):</p>
<pre class="z-code"><code><span class="z-text z-plain">$ ls -alhs ./HelloJS.jsexe
</span><span class="z-text z-plain">... 6.8M ... all.js
</span><span class="z-text z-plain">... 5.5M ... all.min.js
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">$ npx size-limit
</span><span class="z-text z-plain">‚úî Running JS in headless Chrome
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 188.74 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         198.74 kB brotlied
</span><span class="z-text z-plain">  Loading time: 3.9 s     on slow 3G
</span><span class="z-text z-plain">  Running time: 9.6 s     on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   13.5 s
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.min.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 171.55 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         181.55 kB brotlied
</span><span class="z-text z-plain">  Loading time: 3.6 s     on slow 3G
</span><span class="z-text z-plain">  Running time: 7.1 s     on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   10.6 s
</span></code></pre>
<p>Well, results are far from perfect. 10s to load.</p>
<p>Warning for experienced researchers: We are not going to make reliable sigma-based measurements. Their purpose is only to demonstrate the direction of improvements.</p>
<h3 id="efficient-packing-of-string-data-24706">Efficient packing of string data <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24706">#24706</a></h3>
<p>To avoid saying the same things twice (you can follow the issue for details) we are going to disclose it in following samples:</p>
<pre class="z-code"><code><span class="z-text z-plain">[72, 101, 108, 108, 111]
</span></code></pre>
<p><strong>VS</strong></p>
<pre class="z-code"><code><span class="z-text z-plain">Hello
</span></code></pre>
<p>You probably noticed that second sample is shorter than first. It was the point of the ticket. It decreases bundle size besides better readability.</p>
<p>To make it happen let us deal how string literals work in <code>GHC</code>. They become an int array in a memory address pointer which has type <code>Addr#</code> internally. But not only string literals are encoded in an int array (<code>Addr#</code>). GHC is smart enough to use same technique for all embedded stuff which can be represented as an int array with a pointer. It can be used for embedded files as well. For anything that can look like an int array.</p>
<p>So, we should detect somehow that <code>Addr#</code> is used for string literal representation. Fortunately we are dealing with ByteStrings.<br />
According to the <a rel="noopener" target="_blank" href="https://hasufell.github.io/posts/2024-05-07-ultimate-string-guide.html">best article about strings representation (The ultimate guide to Haskell Strings)</a> in GHC, we know that a well-formed unicode string should meet the following requirements:</p>
<ol>
<li>Its content should be limited to UTF8 code points.</li>
<li><code>\0</code>s are not allowed.</li>
</ol>
<p>Pretty small change but how important?</p>
<p>Our <code>HelloWorld.hs</code>:</p>
<pre class="z-code"><code><span class="z-text z-plain">main :: IO ()
</span><span class="z-text z-plain">main = print &quot;HelloWorld&quot;
</span></code></pre>
<p>Result:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ ls -alhs ./HelloJS.jsexe
</span><span class="z-text z-plain">... 6.8M ... all.js
</span><span class="z-text z-plain">... 3.5M ... all.min.js
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">$ npx size-limit
</span><span class="z-text z-plain">‚úî Running JS in headless Chrome
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 185.07 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         195.07 kB brotlied
</span><span class="z-text z-plain">  Loading time: 3.9 s     on slow 3G
</span><span class="z-text z-plain">  Running time: 7.8 s     on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   11.6 s
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.min.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 85.01 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         95.01 kB brotlied
</span><span class="z-text z-plain">  Loading time: 1.9 s    on slow 3G
</span><span class="z-text z-plain">  Running time: 8.2 s    on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   10.1 s
</span></code></pre>
<p>Well, our bundle is becoming smaller in size but it remains expensive to load by a low budget device. Note how important it is to use <code>Google Closure Compiler</code> for production builds!</p>
<h3 id="what-can-be-removed-from-the-bundle-unicode-24504">What can be removed from the bundle? Unicode? <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24504">#24504</a></h3>
<p>While sifting through the contents of <code>app.js</code>, the following was found:</p>
<pre class="z-code"><code><span class="z-text z-plain">var h$ghczminternalZCGHCziInternalziUnicodeziCharziUnicodeDataziGeneralCategoryzilvl_1 = h$rawStringData([25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, ...
</span></code></pre>
<p>That is a really long line of code! It takes 4,316,351 characters at the bundle. What is even more interesting that Google Closure Compiler was unable to eliminate it as a dead code. It sounded like for some reason as really needed by:</p>
<pre class="z-code"><code><span class="z-text z-plain">main :: IO ()
</span><span class="z-text z-plain">main = print &quot;HelloWorld&quot;
</span></code></pre>
<p>It was a challenge to prove that it was exactly needed by the application. A <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/gulin.serge/stg-javascript-backend-visualization">special toolkit</a> was created for call graph analysis
in JavaScript bundles. Its purpose is very simple: It takes the JavaScript AST, reconstructs actual function calls as STG and creates a <a rel="noopener" target="_blank" href="https://graphviz.org/">visualization</a>
to be processed by a graph explorer (e.g. <a rel="noopener" target="_blank" href="https://gephi.org/">Gephi</a>).</p>
<p>When the graph file had been constructed, we only needed to find the shortest path between JavaScript <code>main</code> and <code>h$ghczminternalZCGHCziInternalziUnicodeziCharziUnicodeDataziGeneralCategoryzilvl_1</code>. That route was <a rel="noopener" target="_blank" href="https://ouestware.gitlab.io/retina/beta/#/graph/?url=https://gist.githubusercontent.com/GulinSS/567c098f636d997636a27c91ac98e272/raw/7207d75459770b36a92242f32d7b4ac56adbe77e/network-425dcff1-968.gexf">found</a>!</p>
<p><img src="https://blog.haskell.org/report-of-js-code-minification/./retina-graph-main-to-unicode.png" alt="Monosnap Retina 2024-09-12 18-38-35" /></p>
<blockquote>
<p>Fig. 1. The whole route from main function to Unicode. It demonstrates how much nodes were connected and how. It begins from JavaScript <code>main</code> and ends at <code>h$ghczminternalZCGHCziInternalziUnicodeziCharziUnicodeDataziGeneralCategoryzilvl_1</code>. Total amount of conntected nodes is 30.</p>
</blockquote>
<p>The most interesting node is <code>h$ghczminternalZCGHCziInternalziUnicodezizdwisSpace</code>. It means that <code>isSpace</code> was the only reason why whole Unicode table had been added to the bundle. And <code>isSpace</code> is used by <code>read</code> parser. So, when we call the <code>read</code> function, that dependency route is triggered to be included into result bundle.</p>
<p>It turned out that the root of this issue came from an <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24504">older one</a>. With the help of call graph tracing, it was possible to establish the actual reason and <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12565">fix</a> it! (Ben Gamari, thank you so much)</p>
<p>Measures:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ ls -alhs ./HelloJS.jsexe
</span><span class="z-text z-plain">... 2.2M ... all.js
</span><span class="z-text z-plain">... 387K ... all.min.js
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">$ npx size-limit
</span><span class="z-text z-plain">‚úî Running JS in headless Chrome
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 155.23 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         165.23 kB brotlied
</span><span class="z-text z-plain">  Loading time: 3.3 s     on slow 3G
</span><span class="z-text z-plain">  Running time: 3.1 s     on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   6.3 s
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.min.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 63.92 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         73.92 kB brotlied
</span><span class="z-text z-plain">  Loading time: 1.5 s    on slow 3G
</span><span class="z-text z-plain">  Running time: 2 s      on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   3.4 s
</span></code></pre>
<p>73.92 kB! Even more better! But wait.</p>
<h3 id="what-if-unicode-is-actually-needed-by-some-programs-24789">What if Unicode is actually needed by some programs? <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24789">#24789</a></h3>
<p>As you noted there, it does not require much effort to trigger the addition of the unicode table. A trivial reference to <code>read</code> is enough to pull back the whole table back into the bundle.
That victory is too fragile to be proud of given results. Lots of real applications have to use <code>isSpace</code> when dealing with text parsing and so on. We have to support this case but keep the bundle size low.</p>
<p>Let us consider the following sample program:</p>
<pre class="z-code"><code><span class="z-text z-plain">main :: IO ()
</span><span class="z-text z-plain">main = print (read @Int &quot;1337&quot;)
</span></code></pre>
<p>Here we are facing the issue again.</p>
<p>The variable <code>h$ghczminternalZCGHCziInternalziUnicodeziCharziUnicodeDataziGeneralCategoryzilvl_1</code> stores information about the mapping of each Unicode character to its <a rel="noopener" target="_blank" href="https://www.compart.com/en/unicode/category">General Category</a>. The number of characters in each category varies. Some categories contain significantly more characters than others. When characters are listed sequentially in memory, their order does not necessarily match the order of the categories. This creates <strong>a challenge</strong>: how to organize characters in memory so that the search for their categories is both fast and space-efficient.</p>
<p>Not many ideas came at the beginning, so a <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24789">broad discussion</a> was required with GHC community to see what can be tried to solve this.
Additionally, removing <code>Streamly</code> from GHC sources <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24910">was needed</a> as well because this dependency didn't keep its API stable.</p>
<p><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/Wismill">Pierre Le Marre</a> came <a rel="noopener" target="_blank" href="https://discourse.haskell.org/t/new-library-shamochu-shuffle-and-merge-overlapping-chunks-lossless-compression/9724">with</a> <a rel="noopener" target="_blank" href="https://hackage.haskell.org/package/shamochu-0.1.0.0">ultimate</a> <a rel="noopener" target="_blank" href="https://github.com/haskell/core-libraries-committee/issues/278">solution</a> for the problem with large Unicode table but it was considered <strong>too powerful</strong> to be applied right now, so, the time for <a rel="noopener" target="_blank" href="https://hackage.haskell.org/package/shamochu-0.1.0.0">shamochu</a> will come next.</p>
<p><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/hsyl20">Sylvain Henry</a>'s <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24789#note_563780">approach</a>, less performant in terms of size reduction gains, was deemed much easier to be implemented. The conclusion was to use the latter one because we needed something easier and without additional dependencies at the moment.</p>
<p>The main idea is to generate better lookup code which can be translated into switches:</p>
<pre data-lang="haskell" class="language-haskell z-code"><code class="language-haskell" data-lang="haskell"><span class="z-source z-haskell">generalCategory (ord <span class="z-keyword z-operator z-haskell">-&gt;</span> n)
</span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> <span class="z-keyword z-operator z-haskell">...</span>
</span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> n <span class="z-keyword z-operator z-haskell">&lt;</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">129726</span>  <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">21</span>
</span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> n <span class="z-keyword z-operator z-haskell">&lt;</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">129792</span>  <span class="z-keyword z-operator z-haskell">=</span> lookupIntN <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">&quot;</span>...<span class="z-punctuation z-definition z-string z-end z-haskell">&quot;</span></span># (n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">129726</span>) <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> variable ranges: use lookup tables
</span></span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">...</span>
</span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> n <span class="z-keyword z-operator z-haskell">&lt;</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1048576</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">29</span> <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> constant ranges
</span></span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> n <span class="z-keyword z-operator z-haskell">&lt;</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1114110</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">28</span>
</span><span class="z-source z-haskell">  <span class="z-keyword z-operator z-haskell">|</span> otherwise   <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">29</span>
</span></code></pre>
<p><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/hsyl20">Sylvain Henry's</a> approach was enhanced with nested ifs (logarithmic search vs linear search) and makes estimation regarding the most appropriate chunk size (as he predicted in the origin message):</p>
<p><img src="https://blog.haskell.org/report-of-js-code-minification/general-category-size-reduction.png" alt="image" /></p>
<blockquote>
<p>Fig. 2. Finding the best size of chunks by comparing all possible values against generated function size. It shows that 50 items is a good-enough value of chunks size.</p>
</blockquote>
<p>Measures of applied changes:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ ls -alhs ./HelloJS.jsexe
</span><span class="z-text z-plain">... 2.8M ... all.js
</span><span class="z-text z-plain">... 569K ... all.min.js
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">$ npx size-limit
</span><span class="z-text z-plain">‚úî Running JS in headless Chrome
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 186.88 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         196.88 kB brotlied
</span><span class="z-text z-plain">  Loading time: 3.9 s     on slow 3G
</span><span class="z-text z-plain">  Running time: 4 s       on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   7.9 s
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  HelloJS.jsexe/all.min.js
</span><span class="z-text z-plain">  Package size limit has exceeded by 86.3 kB
</span><span class="z-text z-plain">  Size limit:   10 kB
</span><span class="z-text z-plain">  Size:         96.3 kB brotlied
</span><span class="z-text z-plain">  Loading time: 1.9 s   on slow 3G
</span><span class="z-text z-plain">  Running time: 2.5 s   on Snapdragon 410
</span><span class="z-text z-plain">  Total time:   4.4 s
</span></code></pre>
<p>Well, sizes are looking near same after compression but take a look at <code>Running time</code>. It looks like new version of unicode code is easier to understand by simulated low budget device!</p>
<h2 id="intermediate-conclusions">Intermediate conclusions</h2>
<p>This article shows that community work can yield results that beat the original opinion about "completely unachievable 100kb". We seen how <code>6.8M</code> became <code>2.8M</code> for uncompressed Haskell JavaScript bundle and how <code>181.55 kB</code> became <code>96.3 kB</code> for completely optimized, compressed production-ready JavaScript bundle of trivial Unicode-enabled Haskell JavaScript application.</p>
<p>What is next? Besides <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/23479">adding</a> <a rel="noopener" target="_blank" href="https://hackage.haskell.org/package/shamochu-0.1.0.0">various</a> <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/ghc/ghc/-/issues/24744">code</a> optimizations it would be nice also to consider other options from the beginning:</p>
<ol>
<li>Give a try to slice Haskell applications in chunks, with Webpack dynamic loading as "black box".</li>
<li>Consider adding to GHC JavaScript backend the ability to slice code in CJS/ESM modules.</li>
<li>Rewrite <a rel="noopener" target="_blank" href="https://gitlab.haskell.org/gulin.serge/stg-javascript-backend-visualization">call graph visualization tool</a> in Haskell and make its output compatible with <a rel="noopener" target="_blank" href="https://github.com/webpack-contrib/webpack-bundle-analyzer/">webpack-bundle-analyzer</a>.</li>
<li>Extend GHC JavaScript backend Linker with a feature which would switch on/off built-in modules for environments where they can be already provided by platform.</li>
</ol>
<h2 id="thanks">Thanks!</h2>
<p>Thanks for the long reading! It was a very interesting journey and the author hopes now it was for you too, dear reader! Let us meet together in contributing to GHC!</p>
<p>Thanks for people with whom I was much impressed to work (in alphabetical order):</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/bgamari">Ben Gamari</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/TerrorJack">Cheng Shao</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/Kleidukos">H√©cate Kleidukos</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/doyougnu">Jeffrey Young</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/luite">Luite Stegeman</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/clyring">Matthew Craven</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/mpickering">Matthew Pickering</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/Wismill">Pierre Le Marre</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/alt-romes">Rodrigo Mesquita</a></li>
<li><a rel="noopener" target="_blank" href="https://gitlab.haskell.org/hsyl20">Sylvain Henry</a></li>
</ul>
<p>It is a pleasure to work with all of you on the <strong>Glorious</strong> Glasgow Haskell Compiler! Special thanks for Jeffrey Young who opened a door for me first and invited to work on the GHC JavaScript Backend.</p>

      <nav>
        <div>
          <a href="https://blog.haskell.org/documentation-best-practices-in-2024/">&#8249; Documentation Best Practices in 2024</a>
        </div>
        <div>
          <a href="https://blog.haskell.org/the-haskell-playground/"> The Haskell Playground &#8250;</a>
        </div>
      </nav>
    </article>
  </main>
  <footer>
    <div class="c">
      <nav class="tpad"><div><a type="application/atom+xml" href="https://blog.haskell.org/atom.xml" target="_blank" title="The Haskell Programming Language&#x27;s blog Atom Feed"><i type="Button" class="svg rss" title="The Haskell Programming Language&#x27;s blog Atom Feed"></i></a><a href="https://fosstodon.org/@haskell" target="_blank" title="Mastodon" rel="me"><i type="Button" class="svg mastodon" title="Mastodon"></i></a><a href="https://twitter.com/haskellOrg/" target="_blank" title="Twitter"><i type="Button" class="svg twitter" title="Twitter"></i></a><a href="https://github.com/haskell&#x2F;blog.haskell.org/" target="_blank" title="Github"><i type="Button" class="svg github" title="Github"></i></a></div></nav>
      <p class="s80"> &copy; <span id="year">2025</span> The Haskell Programming Language's blog</p>
      <p class="s80">Powered by <a href="https://www.getzola.org/" target="_blank">Zola</a> & <a href="https://github.com/jieiku/abridge/" target="_blank">Abridge</a></p>
    </div>
  </footer><span class="topout">
<span class="topleft"> </span><a href="#" class="top" title="Back to Top"><i class="svgs svgh angu"></i></a>
</span>
</body>
</html>
